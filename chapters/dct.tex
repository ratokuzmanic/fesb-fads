\section{DCT transformacija}
DCT transformacija je jedna od najčešćih transformacija koju primjenjujemo, a svoju popularnost naspram primjerice 
diskretne Furierove transformacije duguje sljedećim razlozima:
    \begin{enumerate}
        \item Ljudsko oko je senzitivnije na niske frekvencije nego li visoke, a DCT transformacija nam omogućava visoku
        kontrolu nad niskim frekvencijama.
        \item DCT dobro skriva utjecaj blokovne segmentacije.
    \end{enumerate}

Matematički gledano, DCT transformacija se definira kako slijedi:
\begin{center}
    $F(u,v) = \frac{2}{N}*C(u)*C(v)\sum_{x=0}^{N-1}\sum_{y=0}^{N-1}f(x,y)cos(\frac{\pi*(2x+1)*u}{2*N})cos(\frac{\pi*(2y+1)*v}{2*N})$
\end{center}
za $u = 0, ..., N - 1$ i $v = 0, ..., N - 1$,\\
gdje je $N = 8$ i $C(k) = \frac{1}{\sqrt{2}}$ za $k = 0$, a 1 inače.

    \subsection{Implementacija}
Implementacija DCT transformacije u JavaScript jeziku je dana kako slijedi:
\begin{lstlisting}
let cosMap = null;

let memoizeCosines = function(N) {
    cosMap = cosMap || {};
    cosMap[N] = new Array(N*N);

    let PI_N = Math.PI / N;

    for (let k = 0; k < N; k++) {
    for (let n = 0; n < N; n++) {
        cosMap[N][n + (k * N)] = Math.cos(PI_N * (n + 0.5) * k);
    }
    }
};

function dct(signal, scale) {
    let L = signal.length;
    scale = scale || 2;

    if (!cosMap || !cosMap[L]) memoizeCosines(L);

    let coefficients = signal.map(function () {return 0;});

    return coefficients.map(function (__, ix) {
    return scale * signal.reduce(function (prev, cur, ix_, arr) {
        return prev + (cur * cosMap[L][ix_ + (ix * L)]);
    }, 0);
    });
};

module.exports = dct;
\end{lstlisting}

    \subsection{Primjer}
Primjer fotografije na koju je primjenjena DCT transformacija u sklopu JPEG kodiranja
je dana uz originalnu sliku, respektivno, na sljedećoj slici:
\begin{figure}[h]
    \centering
    \includegraphics[width=0.42\textwidth]{original}
    \includegraphics[width=0.42\textwidth]{example-dct}
\end{figure}
